/**
 * ## 해결 전략
 * - 알고리즘: DP
 * - 핵심 아이디어:
 *  - dp[i] = i번 집까지 고려했을 때 훔칠 수 있는 최대 금액
 *   - 인접한 두 집을 연속으로 털 수 없음 (경보 발동) => (i-1) or (i+1) 안됨.
 *   - 특정 위치에서 건너뛸 수도, 털 수도 있는게 특징! => 각 집에서 "털기" 또는 "안 털기" 선택
 *   - i번 집을 털면 최소 1칸은 건너뛰어야 함 (i-2번까지만 고려)
 *
 * - 점화식: dp[i] = max(dp[i-1], dp[i-2] + nums[i])
 *   - dp[i-1]: i번 집 안 털기 (이전까지 최댓값 유지)
 *   - dp[i-2] + nums[i]: i번 집 털기 (전전 집까지 + 현재 집)
 *
 * - 초기값:
 *   - dp[0] = nums[0] (첫 번째 집만 고려)
 *   - dp[1] = max(nums[0], nums[1]) (두 집 중 더 큰 값)
 *
 * - 시간 복잡도: O(n)
 * - 공간 복잡도: O(n)
 *
 * - 핵심 통찰:
 *   - dp[i-2]에 이미 (i-2)번까지의 최적해가 저장되어 있음
 *   - 따라서 dp[i-3], dp[i-4] 등을 별도로 고려할 필요 없음
 */

function solution(nums) {
  const n = nums.length;

  if (n === 0) return 0;
  if (n === 1) return nums[0];

  const dp = new Array(n).fill(0);
  dp[0] = nums[0];
  dp[1] = Math.max(dp[0], nums[1]); // 0번 털고, 1번털 수 없으므로, 최대값으로 초기화

  for (let i = 2; i < n; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
  }
  return dp[n - 1];
}

/**
 * ### 내가 이해하기 위해 해석한 것
 * 2번째 올 수 있는 방법은
 * - 2번째 집 안털기 => dp[1] (이전까지 최댓값 그대로)
 * - 2번째 집 털기 => 1번은 못털고, dp[i-2] 즉 0번째 + nums[2]
 * => 이 두개 비교해서 max값
 * 3번째 올 수 있는 방법은
 * - 3번째 집 안 털기 => dp[2] (이전까지 최댓값 그대로)
 * - 3번째 집 털기 => 2번째 집은 못 털고, dp[i-2] 즉 1번째 + nums[3]
 * => 이 두개의 비교해서 max
 *  => 0번째 집에서 온건 고려 안해도 되는가? 맞다. 이미 dp[1]에 0번까지의 최선이 저장되어 있기 때문에.
 */
