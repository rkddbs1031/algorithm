/**
 * ## 해결 전략
 * - 알고리즘: DP
 * - 핵심 아이디어:
 *   - dp[i][j] = i번 계단까지, j 방법으로 온 경우의 최대 점수
 *     - j = 0: 1칸 점프로 왔음
 *     - j = 1: 2칸 점프로 왔음
 *   - 연속 3칸 금지 = 1칸 점프를 3번 연속 금지
 *   - 마지막 계단은 반드시 밟아야 함
 *
 * - 점화식:
 *   - dp[i][0] = dp[i-1][1] + stairs[i]
 *     (1칸으로 오려면 직전은 반드시 2칸이어야 함 - 연속 방지)
 *   - dp[i][1] = max(dp[i-2][0], dp[i-2][1]) + stairs[i]
 *     (2칸으로 오면 직전은 뭐든 상관없음)
 *
 *
 * - 점화식:
 *   - dp[i][0] = dp[i-1][1] + stairs[i]
 *     (1칸으로 오려면 직전은 반드시 2칸이어야 함 - 연속 방지)
 *   - dp[i][1] = max(dp[i-2][0], dp[i-2][1]) + stairs[i]
 *     (2칸으로 오면 직전은 뭐든 상관없음)
 *
 * - 답: max(dp[n-1][0], dp[n-1][1])
 *
 * - 시간 복잡도: O(n)
 * - 공간 복잡도: O(n)
 */

function solution(stairs) {
  const n = stairs.length;

  if (n === 1) return stairs[0];
  if (n === 2) return stairs[0] + stairs[1];

  /**
   * dp[i][0] = i번에 1칸으로 온 경우
   * dp[i][1] = i번에 2칸으로 온 경우
   */
  const dp = Array.from({ length: n }, () => [0, 0]);
  dp[0][0] = stairs[0];
  dp[0][1] = 0; // 2칸점프로 0번 가는것은 불가하기 때문에

  dp[1][0] = dp[0][0] + stairs[1];
  dp[1][1] = stairs[1];

  for (let i = 2; i < n; i++) {
    dp[i][0] = dp[i - 1][1] + stairs[i];
    dp[i][1] = Math.max(dp[i - 2][0], dp[i - 2][1]) + stairs[i];
  }

  return Math.max(dp[n - 1][0], dp[n - 1][1]);
}

/**
 * 해석해보기
 * 바닥 혹은 0번 계단에서 시작 가능!
 *
 * dp[i][j]
 *  i = 몇 번째 계단인지
 *  j = 어떻게 왔는지
 *      0 = 1칸 점프로 왔음
 *      1 = 2칸 점프로 왔음
 *
 * 0번 계단: (10)
 *  1칸 점프 (바닥 -> 0) => dp[0][0] = 10 => stairs[0]
 *  2칸 점프 => 불가능 => dp[0][1] = 0
 *
 * 1번 계단: (20)
 *  1칸 점프 (0 -> 1) dp[0][0] (10) + 20 => dp[1][0] = 30
 *  2킨 점프 (바닥 -> 1) 20 => dp[1][1] = 20
 *
 * 2번 계단: (15)
 *  1칸 점프 (2칸 점프로 1계단을 와서 -> 1칸 점프로 2계단) => dp[1][1] + 15 => dp[2][0] = 35
 *  2칸 점프 (0에서 -> 2) => max(dp[0][0], dp[0][1]) + 15=> dp[2][1] = 10 + 15 => 25
 *
 * 3번 계단: (25)
 *  1번 점프 (2칸 점프로 2계단을 와서 -> 1칸 점프로 3계단) dp[2][1] + 25 => dp[3][0] = 25 + 25 = 50
 *  2번 점프 (1 -> 3) => max(dp[1][0], dp[1][1]) + 25 = 55
 *
 * ...
 * 즉 점화식은
 *
 * i번째 계단은
 *  1번 점프: dp[i][0] = dp[i-1][1] + stairs[i]
 *  2번 점프: Math.max(dp[i-2][0], dp[i-2][1]) + stairs[i];
 *
 *
 */
